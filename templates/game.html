<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>ä¸‰æ¶ˆç§¯åˆ†æ¸¸æˆ</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    html,body { background: #181a21; color: #fff; font-family: 'Segoe UI', Arial, sans-serif; margin:0; padding:0;}
    h1 {text-align:center; letter-spacing:2px; margin:1em 0 0.5em;}
    .center { text-align:center; }
    canvas { background: #26282f; display: block; margin: 0 auto 12px auto; border-radius: 14px; box-shadow: 0 2px 20px #0008; }
    #scorebar {font-size:1.1rem; letter-spacing:.02em; display:flex; justify-content:center; gap:1.6em; margin-bottom:10px;}
    #gameOverModal { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.87);
      color: #fff; display: none; justify-content: center; align-items: center; flex-direction: column; z-index:99; }
    #gameOverModal button { padding: 12px 34px; margin-top: 26px; background: #18bfff; color: white;
      border: none; border-radius: 8px; font-size:1.1rem; cursor: pointer; box-shadow: 0 2px 6px #0004;}
    #gameOverModal button:hover { background: #0098e0;}
    #controlButton { margin:10px auto; padding:10px 32px; font-size:1.1rem; background:#ffbd2f; color:#2a2a2a; border:0; border-radius:8px; box-shadow:0 1px 8px #ffbb2f2b; cursor:pointer; transition:.15s;}
    #controlButton:hover { background: #ffdf2e;}
    @media (max-width: 650px) {
      canvas { width: 98vw !important; height: 98vw !important; max-width: 98vw !important; max-height: 98vw !important;}
    }
  </style>
</head>
<body>
  <h1>ä¸‰æ¶ˆç§¯åˆ†æ¸¸æˆ</h1>
  <canvas id="gameCanvas"></canvas>
  <div id="scorebar">
      <span>åˆ†æ•°: <b id="score">0</b></span>
      <span>æ­¥æ•°: <b id="moves">30</b></span>
  </div>
  <div class="center">
      <button id="controlButton">å¼€å§‹æ¸¸æˆ</button>
  </div>
  <div id="gameOverModal">
      <h2 style="font-size:2rem;">ğŸ‰ æ¸¸æˆç»“æŸ!</h2>
      <p style="font-size:1.2rem;">ä½ çš„åˆ†æ•°: <span id="finalScore"></span></p>
      <button onclick="restartGame()">å†ç©ä¸€æ¬¡</button>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script>
  // ========== ä¸‰æ¶ˆæ¸¸æˆé€»è¾‘ ==========
  const GRID_SIZE = 8;
  const CELL_SIZE = 56;
  const PADDING = 10;
  const COLORS = [
      "#ff5757", "#ffe457", "#62d9ee", "#7df27d", "#b785f2", "#ff9b7b"
  ];
  const MAX_MOVES = 30;

  let grid = [];
  let score = 0, movesLeft = MAX_MOVES;
  let gameActive = false;
  let selectedCell = null, animating = false;

  // é«˜æ¸… Canvas é€‚é…
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  function resizeCanvas() {
      let logical = GRID_SIZE * CELL_SIZE + PADDING*2;
      let pixelRatio = window.devicePixelRatio || 1;
      let dispWidth = Math.min(window.innerWidth, window.innerHeight, 520) - 12;
      let scale = dispWidth / logical;
      canvas.width = logical * pixelRatio;
      canvas.height = logical * pixelRatio;
      canvas.style.width = logical * scale + 'px';
      canvas.style.height = logical * scale + 'px';
      ctx.setTransform(pixelRatio * scale, 0, 0, pixelRatio * scale, 0, 0);
      render();
  }
  window.addEventListener('resize', resizeCanvas);

  // åˆå§‹åŒ–æ–°ç›˜é¢
  function randomColor() { return Math.floor(Math.random()*COLORS.length);}
  function fillGridNoMatch() {
      for (let row = 0; row < GRID_SIZE; row++) {
          grid[row] = [];
          for (let col = 0; col < GRID_SIZE; col++) {
              do {
                  grid[row][col] = randomColor();
              } while (isMatchAt(row, col));
          }
      }
  }
  function isMatchAt(row, col) {
      const color = grid[row][col];
      if (col>=2 && grid[row][col-1]===color && grid[row][col-2]===color) return true;
      if (row>=2 && grid[row-1][col]===color && grid[row-2][col]===color) return true;
      return false;
  }
  function initGame() {
      fillGridNoMatch();
      score = 0; movesLeft = MAX_MOVES;
      gameActive = false; selectedCell = null; animating = false;
      updateUI();
      document.getElementById('controlButton').textContent = "å¼€å§‹æ¸¸æˆ";
      render();
  }

  function render() {
      let s = CELL_SIZE, pad = PADDING;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // ç»˜åˆ¶æ£‹ç›˜
      for (let row = 0; row < GRID_SIZE; row++) {
          for (let col = 0; col < GRID_SIZE; col++) {
              if (grid[row][col] === null || grid[row][col] === undefined) continue; // ä¿®å¤é»‘å—
              let x = pad + col * s, y = pad + row * s;
              ctx.save();
              ctx.fillStyle = COLORS[grid[row][col]];
              ctx.globalAlpha = 0.92;
              ctx.fillRect(x, y, s-2, s-2);

              // é«˜å…‰
              ctx.globalAlpha = 1;
              let grad = ctx.createLinearGradient(x, y, x+s, y+s);
              grad.addColorStop(0, "#fff5");
              grad.addColorStop(1, COLORS[grid[row][col]]);
              ctx.fillStyle = grad;
              ctx.fillRect(x+3, y+3, s-8, s-14);

              // è¾¹æ¡†
              ctx.strokeStyle = "#222b";
              ctx.lineWidth = 2;
              ctx.strokeRect(x, y, s-2, s-2);

              // é€‰ä¸­é«˜äº®
              if (selectedCell && selectedCell.row === row && selectedCell.col === col) {
                  ctx.strokeStyle = "#ffe153";
                  ctx.lineWidth = 5;
                  ctx.shadowColor = "#ffe153";
                  ctx.shadowBlur = 8;
                  ctx.strokeRect(x+2, y+2, s-6, s-6);
              }
              ctx.restore();
          }
      }
  }

  // è¾“å…¥ä¸äº¤æ¢
  function getCanvasPosition(e) {
      let rect = canvas.getBoundingClientRect();
      let pixelRatio = window.devicePixelRatio || 1;
      let x = ((e.touches ? e.touches[0].clientX : e.clientX) - rect.left);
      let y = ((e.touches ? e.touches[0].clientY : e.clientY) - rect.top);
      let dispWidth = Math.min(window.innerWidth, window.innerHeight, 520) - 12;
      let logical = GRID_SIZE * CELL_SIZE + PADDING*2;
      let scale = logical / dispWidth;
      return { x: x*scale, y: y*scale };
  }
  function getCellFromPosition(x, y) {
      const col = Math.floor((x-PADDING) / CELL_SIZE);
      const row = Math.floor((y-PADDING) / CELL_SIZE);
      if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE) {
          return { row, col };
      }
      return null;
  }
  function cellsEqual(cell1, cell2) {
      return cell1 && cell2 && cell1.row === cell2.row && cell1.col === cell2.col;
  }
  function areAdjacent(cell1, cell2) {
      const rowDiff = Math.abs(cell1.row - cell2.row);
      const colDiff = Math.abs(cell1.col - cell2.col);
      return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
  }

  function trySwap(cell1, cell2) {
      if (!gameActive || animating) return;
      swap(cell1, cell2);
      let matches = findMatches();
      if (matches.length === 0) {
          setTimeout(() => { swap(cell1, cell2); selectedCell = null; render(); }, 180);
      } else {
          movesLeft--;
          processMatches(matches, function() {
              selectedCell = null;
              updateUI();
              if (movesLeft <= 0) endGame();
          });
      }
      render();
  }

  function swap(cell1, cell2) {
      let tmp = grid[cell1.row][cell1.col];
      grid[cell1.row][cell1.col] = grid[cell2.row][cell2.col];
      grid[cell2.row][cell2.col] = tmp;
  }

  function findMatches() {
      let matches = [];
      // è¡Œ
      for (let row = 0; row < GRID_SIZE; row++) {
          let cnt = 1, prev = grid[row][0];
          for (let col = 1; col < GRID_SIZE; col++) {
              if (grid[row][col] === prev) cnt++;
              else {
                  if (cnt >= 3) matches.push({ type:'row', row, col:col-cnt, len:cnt });
                  cnt = 1; prev = grid[row][col];
              }
          }
          if (cnt >= 3) matches.push({ type:'row', row, col:GRID_SIZE-cnt, len:cnt });
      }
      // åˆ—
      for (let col = 0; col < GRID_SIZE; col++) {
          let cnt = 1, prev = grid[0][col];
          for (let row = 1; row < GRID_SIZE; row++) {
              if (grid[row][col] === prev) cnt++;
              else {
                  if (cnt >= 3) matches.push({ type:'col', col, row:row-cnt, len:cnt });
                  cnt = 1; prev = grid[row][col];
              }
          }
          if (cnt >= 3) matches.push({ type:'col', col, row:GRID_SIZE-cnt, len:cnt });
      }
      return matches;
  }

  function processMatches(matches, cb) {
      animating = true;
      let toClear = Array.from({length:GRID_SIZE},()=>Array(GRID_SIZE).fill(false));
      for (let m of matches) {
          if (m.type==='row') for(let c=0;c<m.len;c++) toClear[m.row][m.col+c]=true;
          else for(let r=0;r<m.len;r++) toClear[m.row+r][m.col]=true;
      }
      let cleared = 0;
      for (let r = 0; r < GRID_SIZE; r++) for (let c = 0; c < GRID_SIZE; c++) if (toClear[r][c]) cleared++;
      score += cleared * 20;
      updateUI();

      // æ¶ˆé™¤é—ªçƒåŠ¨ç”»
      let flashCt=0;
      let flash = setInterval(()=>{
          for (let r=0;r<GRID_SIZE;r++) for(let c=0;c<GRID_SIZE;c++)
              if(toClear[r][c]) grid[r][c] = null;
          render();
          flashCt++;
          if (flashCt>1) {
              clearInterval(flash);
              dropAndFill(toClear, cb);
          }
      }, 100);
  }
  function dropAndFill(toClear, cb) {
      for (let c = 0; c < GRID_SIZE; c++) {
          let pointer = GRID_SIZE-1;
          for (let r = GRID_SIZE-1; r >=0; r--) {
              if (!toClear[r][c]) {
                  grid[pointer][c] = grid[r][c];
                  pointer--;
              }
          }
          for (let r=pointer;r>=0;r--) grid[r][c]=randomColor();
      }
      render();
      setTimeout(()=>{
          let m = findMatches();
          if(m.length>0) processMatches(m, cb);
          else { animating=false; cb&&cb(); }
      }, 140);
  }

  // äº¤äº’
  canvas.addEventListener('click', handleInput);
  canvas.addEventListener('touchstart', handleInput);
  function handleInput(e) {
      if (!gameActive || animating) return;
      let pos = getCanvasPosition(e);
      let cell = getCellFromPosition(pos.x, pos.y);
      if (!cell) return;
      if (!selectedCell) {
          selectedCell = cell;
      } else if (cellsEqual(selectedCell, cell)) {
          selectedCell = null;
      } else if (areAdjacent(selectedCell, cell)) {
          trySwap(selectedCell, cell);
          selectedCell = null;
      } else {
          selectedCell = cell;
      }
      render();
      if (e.touches) e.preventDefault();
  }

  function updateUI() {
      document.getElementById('score').textContent = score;
      document.getElementById('moves').textContent = movesLeft;
  }
  function endGame() {
      gameActive = false;
      document.getElementById('finalScore').textContent = score;
      document.getElementById('gameOverModal').style.display = 'flex';
      submitScore();
  }
  function restartGame() {
      document.getElementById('gameOverModal').style.display = 'none';
      initGame();
  }

  // ä½ çš„åç«¯ç”¨æˆ·ID
  let userId = '100001';
  function submitScore() {
      $.post("/play", {
          user_id: userId,
          score: score,
          game_name: "ä¸‰æ¶ˆæ¸¸æˆ"
      }, function(data) {
          // ä¸Šä¼ æˆåŠŸé€»è¾‘
      }).fail(function(err) {
          alert("æäº¤å¤±è´¥: " + (err.responseJSON?.error || "æœªçŸ¥é”™è¯¯"));
      });
  }

  document.getElementById('controlButton').addEventListener('click', () => {
      if (!gameActive) {
          gameActive = true;
          document.getElementById('controlButton').textContent = "æš‚åœ";
          render();
          return;
      }
      // æš‚åœå¯å®ç°ï¼Œä½†ä¸‰æ¶ˆæ­¥æ•°å‹ä¸€èˆ¬æ— æš‚åœ
  });

  // åˆå§‹åŒ–
  initGame();
  setTimeout(resizeCanvas, 20);

  </script>
</body>
</html>
