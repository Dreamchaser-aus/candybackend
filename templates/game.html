<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>ä¸‰æ¶ˆç§¯åˆ†æ¸¸æˆ</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    html,body { background: linear-gradient(120deg, #23243a 0%, #1c2037 100%);
      color: #fff; font-family: 'Segoe UI', Arial, sans-serif; margin:0; padding:0;}
    h1 {text-align:center; letter-spacing:2px; margin:1.2em 0 0.5em; font-weight:800; text-shadow:0 4px 22px #5d7aff55;}
    .game-box { background:rgba(30,34,55,0.98); border-radius:24px; margin:0 auto; max-width:650px; box-shadow:0 8px 38px #0009; padding:22px 18px 18px 18px;}
    canvas { background: linear-gradient(160deg,#252845 80%,#1d1e30 100%);
      display:block; margin:0 auto 16px auto; border-radius:22px; box-shadow:0 8px 32px #4349c033,0 1.5px 4px #0007;}
    #scorebar {
      font-size:1.14rem; letter-spacing:.03em; display:flex; justify-content:center; gap:1.9em; margin-bottom:14px;
      background:rgba(255,255,255,0.11); border-radius:16px; box-shadow:0 0.5px 4px #2234d044; padding:7px 0 3px 0;
      font-weight:600;
    }
    #gameOverModal { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(20,18,34,0.98);
      color: #fff; display: none; justify-content: center; align-items: center; flex-direction: column; z-index:99; }
    #gameOverModal button { padding: 13px 36px; margin-top: 28px; background: linear-gradient(90deg,#28c7fa,#5468ff 95%);
      color: white; border: none; border-radius: 10px; font-size:1.13rem; cursor: pointer; font-weight:700; box-shadow:0 2px 10px #28c7fa22;}
    #gameOverModal button:hover { background:linear-gradient(90deg,#5468ff,#28c7fa);}
    #controlButton { margin:10px auto 0; padding:12px 44px; font-size:1.13rem;
      background:linear-gradient(90deg,#ffd048,#ff7e54); color:#222; border:0; border-radius:12px;
      font-weight:700; box-shadow:0 1px 9px #ffd0483c; cursor:pointer; transition:.16s;}
    #controlButton:hover { background:linear-gradient(90deg,#ffe95a,#ffad54);}
    @media (max-width: 800px) {
      .game-box {max-width:99vw;}
      canvas { width:98vw !important; height:98vw !important; max-width:98vw !important; max-height:98vw !important;}
    }
  </style>
</head>
<body>
  <h1>ä¸‰æ¶ˆç§¯åˆ†æ¸¸æˆ</h1>
  <div class="game-box">
    <canvas id="gameCanvas"></canvas>
    <div id="scorebar">
        <span>åˆ†æ•°: <b id="score">0</b></span>
        <span>æ­¥æ•°: <b id="moves">30</b></span>
    </div>
    <div class="center">
        <button id="controlButton">å¼€å§‹æ¸¸æˆ</button>
    </div>
  </div>
  <div id="gameOverModal">
      <h2 style="font-size:2rem;letter-spacing:3px;">ğŸ‰ æ¸¸æˆç»“æŸ!</h2>
      <p style="font-size:1.18rem;margin-top:6px;">ä½ çš„åˆ†æ•°: <span id="finalScore"></span></p>
      <button onclick="restartGame()">å†ç©ä¸€æ¬¡</button>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script>
  // ========== ä¸‰æ¶ˆæ¸¸æˆé€»è¾‘ ==========
  const GRID_SIZE = 8;
  const CELL_SIZE = 56;
  const PADDING = 14;
  const COLORS = [
      ["#ff6e90", "#ffe9ef"], // çº¢-æ¸å˜
      ["#ffe457", "#fff7c5"], // é»„
      ["#62d9ee", "#d8f5ff"], // è“
      ["#7df27d", "#e2ffe7"], // ç»¿
      ["#b785f2", "#f3eaff"], // ç´«
      ["#ffad54", "#fff2dd"], // æ©™
  ];
  const MAX_MOVES = 30;

  let grid = [];
  let score = 0, movesLeft = MAX_MOVES;
  let gameActive = false;
  let selectedCell = null, animating = false;

  // è‡ªé€‚åº”æ£‹ç›˜
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  function resizeCanvas() {
      let logical = GRID_SIZE * CELL_SIZE + PADDING * 2;
      let availW = window.innerWidth - 24;
      let availH = window.innerHeight - 320; // é¢„ç•™æ ‡é¢˜æŒ‰é’®
      let dispSize = Math.min(availW, availH, 500, logical);
      let pixelRatio = window.devicePixelRatio || 1;
      canvas.width = logical * pixelRatio;
      canvas.height = logical * pixelRatio;
      canvas.style.width = dispSize + 'px';
      canvas.style.height = dispSize + 'px';
      let scale = dispSize / logical;
      ctx.setTransform(pixelRatio * scale, 0, 0, pixelRatio * scale, 0, 0);
      render();
  }
  window.addEventListener('resize', resizeCanvas);

  function randomColor() { return Math.floor(Math.random()*COLORS.length);}
  function fillGridNoMatch() {
      for (let row = 0; row < GRID_SIZE; row++) {
          grid[row] = [];
          for (let col = 0; col < GRID_SIZE; col++) {
              do {
                  grid[row][col] = randomColor();
              } while (isMatchAt(row, col));
          }
      }
  }
  function isMatchAt(row, col) {
      const color = grid[row][col];
      if (col>=2 && grid[row][col-1]===color && grid[row][col-2]===color) return true;
      if (row>=2 && grid[row-1][col]===color && grid[row-2][col]===color) return true;
      return false;
  }
  function initGame() {
      fillGridNoMatch();
      score = 0; movesLeft = MAX_MOVES;
      gameActive = false; selectedCell = null; animating = false;
      updateUI();
      document.getElementById('controlButton').textContent = "å¼€å§‹æ¸¸æˆ";
      render();
  }

  function render() {
      let s = CELL_SIZE, pad = PADDING;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // èƒŒæ™¯å†…é˜´å½±
      ctx.save();
      ctx.shadowColor = "#2231c6cc";
      ctx.shadowBlur = 32;
      ctx.fillStyle = "#202339";
      ctx.fillRect(pad-8, pad-8, s*GRID_SIZE+16, s*GRID_SIZE+16);
      ctx.restore();

      // æ£‹ç›˜
      for (let row = 0; row < GRID_SIZE; row++) {
          for (let col = 0; col < GRID_SIZE; col++) {
              if (grid[row][col] === null || grid[row][col] === undefined) continue;
              let colorIdx = grid[row][col];
              let x = pad + col * s, y = pad + row * s;
              ctx.save();

              // æ¸å˜å—
              let grad = ctx.createLinearGradient(x, y, x+s, y+s);
              grad.addColorStop(0, COLORS[colorIdx][0]);
              grad.addColorStop(1, COLORS[colorIdx][1]);
              ctx.fillStyle = grad;
              ctx.globalAlpha = 0.99;
              ctx.fillRect(x, y, s-3, s-3);

              // å‘å…‰é«˜å…‰
              ctx.globalAlpha = 1;
              let glow = ctx.createRadialGradient(x+s/2, y+s/2, 8, x+s/2, y+s/2, s/1.15);
              glow.addColorStop(0, "#fff9");
              glow.addColorStop(1, COLORS[colorIdx][1]+"00");
              ctx.fillStyle = glow;
              ctx.fillRect(x+3, y+3, s-8, s-13);

              // è¾¹æ¡†
              ctx.strokeStyle = "#fff2";
              ctx.lineWidth = 2;
              ctx.strokeRect(x, y, s-3, s-3);

              // é€‰ä¸­é«˜äº®+å…‰åœˆ
              if (selectedCell && selectedCell.row === row && selectedCell.col === col) {
                  ctx.save();
                  ctx.strokeStyle = "#28c7fa";
                  ctx.shadowColor = "#28c7fa";
                  ctx.shadowBlur = 16;
                  ctx.lineWidth = 7;
                  ctx.globalAlpha = 0.86;
                  ctx.strokeRect(x+1, y+1, s-5, s-5);
                  ctx.restore();
              }
              ctx.restore();
          }
      }
  }

  // è¾“å…¥ä¸äº¤æ¢
  function getCanvasPosition(e) {
      let rect = canvas.getBoundingClientRect();
      let x = ((e.touches ? e.touches[0].clientX : e.clientX) - rect.left);
      let y = ((e.touches ? e.touches[0].clientY : e.clientY) - rect.top);
      let logical = GRID_SIZE * CELL_SIZE + PADDING * 2;
      let cssW = parseFloat(canvas.style.width);
      let scale = logical / cssW;
      return { x: x*scale, y: y*scale };
  }
  function getCellFromPosition(x, y) {
      const col = Math.floor((x-PADDING) / CELL_SIZE);
      const row = Math.floor((y-PADDING) / CELL_SIZE);
      if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE) {
          return { row, col };
      }
      return null;
  }
  function cellsEqual(cell1, cell2) {
      return cell1 && cell2 && cell1.row === cell2.row && cell1.col === cell2.col;
  }
  function areAdjacent(cell1, cell2) {
      const rowDiff = Math.abs(cell1.row - cell2.row);
      const colDiff = Math.abs(cell1.col - cell2.col);
      return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
  }

  function trySwap(cell1, cell2) {
      if (!gameActive || animating) return;
      swap(cell1, cell2);
      let matches = findMatches();
      if (matches.length === 0) {
          setTimeout(() => { swap(cell1, cell2); selectedCell = null; render(); }, 180);
      } else {
          movesLeft--;
          processMatches(matches, function() {
              selectedCell = null;
              updateUI();
              if (movesLeft <= 0) endGame();
          });
      }
      render();
  }

  function swap(cell1, cell2) {
      let tmp = grid[cell1.row][cell1.col];
      grid[cell1.row][cell1.col] = grid[cell2.row][cell2.col];
      grid[cell2.row][cell2.col] = tmp;
  }

  function findMatches() {
      let matches = [];
      for (let row = 0; row < GRID_SIZE; row++) {
          let cnt = 1, prev = grid[row][0];
          for (let col = 1; col < GRID_SIZE; col++) {
              if (grid[row][col] === prev) cnt++;
              else {
                  if (cnt >= 3) matches.push({ type:'row', row, col:col-cnt, len:cnt });
                  cnt = 1; prev = grid[row][col];
              }
          }
          if (cnt >= 3) matches.push({ type:'row', row, col:GRID_SIZE-cnt, len:cnt });
      }
      for (let col = 0; col < GRID_SIZE; col++) {
          let cnt = 1, prev = grid[0][col];
          for (let row = 1; row < GRID_SIZE; row++) {
              if (grid[row][col] === prev) cnt++;
              else {
                  if (cnt >= 3) matches.push({ type:'col', col, row:row-cnt, len:cnt });
                  cnt = 1; prev = grid[row][col];
              }
          }
          if (cnt >= 3) matches.push({ type:'col', col, row:GRID_SIZE-cnt, len:cnt });
      }
      return matches;
  }

  function processMatches(matches, cb) {
      animating = true;
      let toClear = Array.from({length:GRID_SIZE},()=>Array(GRID_SIZE).fill(false));
      for (let m of matches) {
          if (m.type==='row') for(let c=0;c<m.len;c++) toClear[m.row][m.col+c]=true;
          else for(let r=0;r<m.len;r++) toClear[m.row+r][m.col]=true;
      }
      let cleared = 0;
      for (let r = 0; r < GRID_SIZE; r++) for (let c = 0; c < GRID_SIZE; c++) if (toClear[r][c]) cleared++;
      score += cleared * 20;
      updateUI();

      // æ¶ˆé™¤é—ªçƒåŠ¨ç”»
      let flashCt=0;
      let flash = setInterval(()=>{
          for (let r=0;r<GRID_SIZE;r++) for(let c=0;c<GRID_SIZE;c++)
              if(toClear[r][c]) grid[r][c] = null;
          render();
          flashCt++;
          if (flashCt>1) {
              clearInterval(flash);
              dropAndFill(toClear, cb);
          }
      }, 100);
  }
  function dropAndFill(toClear, cb) {
      for (let c = 0; c < GRID_SIZE; c++) {
          let pointer = GRID_SIZE-1;
          for (let r = GRID_SIZE-1; r >=0; r--) {
              if (!toClear[r][c]) {
                  grid[pointer][c] = grid[r][c];
                  pointer--;
              }
          }
          for (let r=pointer;r>=0;r--) grid[r][c]=randomColor();
      }
      render();
      setTimeout(()=>{
          let m = findMatches();
          if(m.length>0) processMatches(m, cb);
          else { animating=false; cb&&cb(); }
      }, 140);
  }

  canvas.addEventListener('click', handleInput);
  canvas.addEventListener('touchstart', handleInput);
  function handleInput(e) {
      if (!gameActive || animating) return;
      let pos = getCanvasPosition(e);
      let cell = getCellFromPosition(pos.x, pos.y);
      if (!cell) return;
      if (!selectedCell) {
          selectedCell = cell;
      } else if (cellsEqual(selectedCell, cell)) {
          selectedCell = null;
      } else if (areAdjacent(selectedCell, cell)) {
          trySwap(selectedCell, cell);
          selectedCell = null;
      } else {
          selectedCell = cell;
      }
      render();
      if (e.touches) e.preventDefault();
  }

  function updateUI() {
      document.getElementById('score').textContent = score;
      document.getElementById('moves').textContent = movesLeft;
  }
  function endGame() {
      gameActive = false;
      document.getElementById('finalScore').textContent = score;
      document.getElementById('gameOverModal').style.display = 'flex';
      submitScore();
  }
  function restartGame() {
      document.getElementById('gameOverModal').style.display = 'none';
      initGame();
  }

  // ä½ çš„åç«¯ç”¨æˆ·ID
  let userId = '100001';
  function submitScore() {
      $.post("/play", {
          user_id: userId,
          score: score,
          game_name: "ä¸‰æ¶ˆæ¸¸æˆ"
      }, function(data) {
          // ä¸Šä¼ æˆåŠŸé€»è¾‘
      }).fail(function(err) {
          alert("æäº¤å¤±è´¥: " + (err.responseJSON?.error || "æœªçŸ¥é”™è¯¯"));
      });
  }

  document.getElementById('controlButton').addEventListener('click', () => {
      if (!gameActive) {
          gameActive = true;
          document.getElementById('controlButton').textContent = "æš‚åœ";
          render();
          return;
      }
  });

  initGame();
  setTimeout(resizeCanvas, 30);

  </script>
</body>
</html>
